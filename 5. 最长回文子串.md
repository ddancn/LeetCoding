题目：

给定一个字符串 s，找到 s 中最长的回文子串。你可以假设 s 的最大长度为 1000。

示例：

输入: "babad"
输出: "bab"或"aba"

## 解法
### 解法1：暴力
虽然一时想用最长子串的滑动窗口思想失败了，因为当一个子串不是回文串的时候，到底是left++还是right++呢？好像都不大对哦。
但是我们还是可以用同样的世界，同一种暴力法~去对每个子串求它是否是回文

### 解法2：最长公共子串
这里我们可以借用最长公共子串的实现，对s和s的反转求最长公共子串。如ababc和cbaba就可以求出aba。
然而abc123cba和abc321cba居然可以求出abc和cba？显然它们都不是回文。而这是因为原字符串中就包含着自己的回文的关系，反转后自然会得到和自身一样的值。

然而并不是说我们就不能用这个方法了。找出子串后，我们可以检查反转串中子串的下标在反转前是不是等于原字符串中子串的下标

### 解法3：动态规划
如果aba是回文，babab显然也是回文。于是就有了这么一个公式（？）`s(i,j)是回文且s[i-1]==s[j+1]推得s(i-1,j+1)也是回文`。
所以我们可以先初始化一个字和两个字的回文，再往外推

### 解法4：中心扩展
可以从某一个字符开始，向它两边扩展，判断是否是回文串。一共有2n-1个这样的中心（其中n-1个是偶数时的回文中心）。每次扩展回文需要On，一共On2
