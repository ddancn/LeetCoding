题目：

实现 strStr() 函数。

给定一个 haystack 字符串和一个 needle 字符串，在 haystack 字符串中找出 needle 字符串出现的第一个位置 (从0开始)。如果不存在，则返回  -1。

示例 1:
>输入: haystack = "hello", needle = "ll"  
输出: 2  

示例 2:
>输入: haystack = "aaaaa", needle = "bba"  
输出: -1

## 解法
>大(cao)海(duo)捞针可还行
### 解法1：暴力循环
机智如我立马又拿循环套起了循环。。在每一个haystack中有匹配到needle第一个字的，就顺着往下匹配，有则返回，无则从刚刚的0下标的下一个开始再匹配
（一开始还写的直接从失败的地方往下匹配，被残忍拒绝）
```kotlin
class Solution {
    fun strStr(haystack: String, needle: String): Int {
        if (needle.isEmpty()) return 0
        var i1 = 0
        var i2 = 0
        while (i1 < haystack.length) {
            while (i1 < haystack.length && haystack[i1++] == needle[i2++]) {
                if (i2 == needle.length) return i1 - needle.length
            }
            i1 = i1 - i2 + 1
            i2 = 0
        }
        return -1
    }
}
```
虽然我知道我的复杂度是O(mn)，但是打败了17%的人也太伤人了吧。。依稀想起了KMP算法，可是我不记得了呀。。

### 解法2：KMP算法
中心思想是利用之前已经匹配过的不匹配的字符串，虽然它不匹配，但是我知道已经经过了什么字了，很多时候没有必要又从i+1的地方开始，可以找出更合适的起始下标
>那么接下来是不是又要从头开始了呢？
