题目：

给出一个32位有符号整数，对其每一位上的数字进行反转

示例 1:

>输入: 123  
>输出: 321

示例 2:

>输入: -123  
>输出: -321

示例 3:

>输入: 120  
>输出: 21

注意:

假设我们的环境只能存储得下 32 位的有符号整数，其数值范围为 [−2^31,  2^31 − 1]。请根据这个假设，如果反转后整数溢出就返回 0。

## 思路和解法
如果题目不给出这几个示例，我还不会想针对负数特殊处理，但其实根本不用。。
对整数进行反转其实比较简单，直接对10取余，然后余数挨个进位累积加起来（具体看代码）就好了。  

但是要判断是否溢出就有点麻烦，先说两个另辟蹊径的方法：
* 把整数转成string，反转后再转回int，溢出可以try-catch解决（效率较低且不是题目本意）
* 使用long类型存储结果，判断是否大于2^31 − 1（但题目说只有32位的存储空间，所以这个方法其实是不行的）

那么大概只能从数学计算方面考虑溢出情况了。先看一下基本的解法：
```kotlin
class Solution {
    fun reverse(x: Int): Int {
        var y = x // kotlin的参数默认是不可变的
        var result = 0
        while (y != 0) {
            val remainder = y % 10
            // TODO 在这里进行检查溢出
            result = result * 10 + remainder
            y /= 10
        }
        return result
    }
}
```
我们在每次计算新的`result`之前，检查一下是否溢出。  
如有`result * 10 + remainder > Int.MAX_VALUE`即为溢出，那么有两个可能的原因：
* `result > Int.MAX_VALUE / 10`，这必定会造成溢出
* `result == Int.MAX_VALUE / 10 and remainder > 7`，有的小朋友可能要说了：出现了！万恶的魔法值！  
emmm，那么7是怎么来的呢？7是2^31 − 1的个位数（啊？咋算的？实不相瞒，找规律。或者为了通用性，我们直接%10）。
那么要它的个位数干嘛呢？显然如果前面n-1位都相等了，就只能比最后一位了呗。。  

负数的情况也是类似的：
* `result < Int.MIN_VALUE / 10`，一定溢出
* `result == Int.MIN_VALUE / 10 and remainder < -8`，也一定溢出，这里8是-2^31的个位数

修改之后的代码：
```kotlin
class Solution {
    fun reverse(x: Int): Int {
        var y = x // kotlin的参数默认是不可变的
        var result = 0
        while (y != 0) {
            val remainder = y % 10
            if (result > Int.MAX_VALUE / 10 || ((result == Int.MAX_VALUE / 10) && (remainder > Int.MAX_VALUE % 10))) return 0
            if (result < Int.MIN_VALUE / 10 || ((result == Int.MIN_VALUE / 10) && (remainder < Int.MIN_VALUE % 10))) return 0
            result = result * 10 + remainder
            y /= 10
        }
        return result
    }
}
```
本来还在想有没有不用比较大小的方法。。看来是没有  
看到有评论说remainder到最后一位只能是1或2，因为2^31就是21亿多，不用判断7或-8。问题是我咋就能记得它是几呢/摊手

## 思考

### int溢出之后是怎么处理的？得到的数是怎么来的？
Integer.parse(string)溢出会报错，怎么int本身相加溢出不会呢？  

事实上，在做加法时，如果计算结果太大了，java会做默认的类型提升，并将中间结果保存在一个long中，
但是在返回的时候，发现目标类型是int，不能够存放下数据，就会做一个变窄处理，把宽于int的部分都丢掉，只取结果的低32位  

ps：虽然是说java，但是kotlin应该也差不多吧

### 为什么Int.MAX_VALUE+1 = Int.MIN_VALUE？计算机是怎么表示数值的？

同学，来复习计算机组成原理了。。首先计算机肯定是用0101二进制来表示数值的，并且用最高位当做符号位。带符号位的叫机器数，机器数对应的真正数值叫真值。
>比如有符号数 10000011，其最高位1代表负，其真值是 -3 而不是131

依稀记得二进制数值有原码、反码、补码三种形式，先回忆一下它们的计算方式  

|  | 原码 | 反码 | 补码 |
| --- | --- | --- | --- |
| 正数 | 第一位表示符号，其余位表示值 | 同原码 | 同原码 |
| 负数 | 同正数 | 原码符号位不变，其余按位取反 | 反码+1 |

等等，但是我压根不记得为什么要这样算啊。。甚至它们为什么要存在三个码？这个。。就要从计算机的运算开始补起了  

>计组老师：我很痛心

我们知道，原码是很接近数字的真实值的，但是它是带有符号位的，如果在计算机运算时，还要对符号位和真值的部分分开处理，这也太复杂了吧。  

所以有人灵机一动，减去一个正数就是加上对应的负数，能不能让符号位也参与计算，这样也不用考虑减法了，只保留加法岂不是美滋滋？  

但是只用原码的话，似乎是达不到这个效果的，因为：
>1 - 1 = 1 + (-1) = [00000001]原 + [10000001]原 = [10000010]原 = -2

emmm，于是反码就出现了：
>1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]反 + [1111 1110]反 = [1111 1111]反 = [1000 0000]原 = -0

用反码来做加法，就可以达成减法的效果了！但是-0又是什么鬼呢，0还分正负吗？于是补码的出现，就是为了解决两个0的问题：
>1 - 1 = 1 + (-1) = [0000 0001]原 + [1000 0001]原 = [0000 0001]补 + [1111 1111]补 = [0000 0000]补 = [0000 0000]原

这样0用[0000 0000]表示，而-0则不存在了，多出来的[1000 0000]还可以用来表示-128，妙啊。
>(-1) + (-127) = [1000 0001]原 + [1111 1111]原 = [1111 1111]补 + [1000 0001]补 = [1000 0000]补

所以8位二进制, 使用原码或反码表示的范围为[-127, +127], 而使用补码表示的范围为[-128, 127]。  

于是计算机最后使用了补码来表示数值，对于编程中常用到的32位int类型, 可以表示的范围就是: [-2^31, 2^31-1]，
只有一个0，负数比正数多一个，因为把本来的-0改成去表示负数最小值了

**感谢**  
[Java中整数溢出的问题](https://bbs.csdn.net/topics/40216116) 参考了一个03年的帖子，真是..哀吾生之须臾？  
[原码, 反码, 补码 详解](https://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html)
