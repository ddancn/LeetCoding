题目：

给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。假设数组中无重复元素。

示例:
>[1,3,5,6], 5->2  
[1,3,5,6], 2->1  
[1,3,5,6], 7->4  
[1,3,5,6], 0->0

## 解法
### 解法1：直接
很少碰到这种简单得让我直接白板敲了出来的题。。
```kotlin
class Solution {
    fun searchInsert(nums: IntArray, target: Int): Int {
        if(nums.size == 0 || target <= nums[0]) return 0
        
        nums.forEachIndexed{index, num -> 
            if(num >= target) return index
        }
        return nums.size
    }
}
```
当我判断了空数组的情况后，我发现官方它根本不判断，输入空就会报错。。
不过复杂度是O(n)，还可以继续优化

### 解法2：二分法
```kotlin
class Solution {
    fun searchInsert(nums: IntArray, target: Int): Int {
        var left = 0
        var right = nums.size - 1
        while(left <= right){
            var mid = (left + right) / 2
            if(nums[mid] == target){
                return mid
            } else if(nums[mid] < target){
                left = mid + 1
            } else {
                right = mid - 1
            }
        }
        return left
    }
}
```
二分法的复杂度自然就是O(logn)啦

## 学习
>我本来以为二分法这么简单还有什么好说的，没想到居然有大佬出了好长一篇的分享，吓得我赶紧学习一下

在有序数组中查找一个目标数值或类似问题，大多数可以用二分法来解决。二分法虽然简单易懂，但实现上却有一些细节的问题需要注意：
1. 取中位数的代码`mid = (left + right) / 2`，当left和right都较大时，可能造成整数溢出
2. 使用循环条件`while(left <= right)`，退出循环后还需根据题意判断是返回left还是right

针对这两个问题：
1. 可以用`mid = left + (right - left) / 2`来代替，但是当right很大、 left是负数且很小的时候， right - left也有可能溢出，
只是一般情况下 left 和 right 表示的是数组索引值，left 是非负数，因此溢出的可能性很小。
更好的写法是`mid = (left + right) >>> 1`，无符号右移。无符号的移动会在左边补上0，溢出后的负数也会变成正数。
2. 可以把循环条件写成`while(left < right)`，这样返回left或right都可以。但是这样中间还有一个数没判断呢？那就退出循环后再判断。
如果可以确定`left==right`时就是想找的那个值，甚至可以不用判断。

以上是两个比较大的问题，有关其他注意事项：
* 只写两个分支，不专门处理中位数的情况。因为想找的值刚好是中位数的情况比较少见
* 其中一个分支的边界排除了中位数，另一个就不用排除
>以上写法有如下问题：偶数个元素时，有分左中位数和右中位数，区别在`left + right要不要+1`。
如果计算mid时选左中位数，且分支中写的是`left = mid`和`right = mid - 1`，
那么在最后剩两个数时，就会进入死循环。因为左边界不能得到更新，区间不能缩小，右边同理。
* 哪个分支简单先写哪个
* 左右边界的选择，一定要包含可能的目标，不然到最后都找不到

**感谢：**  
[十分好用的二分查找法模板](https://leetcode-cn.com/problems/search-insert-position/solution/te-bie-hao-yong-de-er-fen-cha-fa-fa-mo-ban-python-/)

>这位仁兄虽然写的很好很长很详细，但是同样的东西翻来覆去讲了好几遍，看的心累。。
