题目：

给定一个数字，我们按照如下规则把它翻译为字符串：0 对应 a ，1 对应 b，……，11 对应 l，……，25 对应 z。  
一个数字可能有多个翻译。请编程实现一个函数，用来计算一个数字有多少种不同的翻译方法。

示例:
>输入: 12258  
输出: 5  
解释: 12258有5种不同的翻译，分别是"bccfi", "bwfi", "bczi", "mcfi"和"mzi"

## 解法
### 解法1：递归
>本来还想用一个map保存26种映射，但是发现这其实只要算多少种就好了

感觉这有点递归，应该是一串数字去掉一个和去掉两个，作为两种情况再去递归。经过了种种尝试，我写出了以下代码：
* 从尾部开始，去除一或两个数字，再去递归（这和从头部开始是一样的）
* 显然，0\~9的数字只有一种翻译法，10\~25则都有两种翻译法，可以直接返回
* 如果输入`12258`，本应递归`1225`和`122`。但是`58`明显没有对应，所以`122`这种情况是不存在滴，所以我们得到了`num % 100 <= 25`的条件
* 如果输入`506`，本应递归`50`和`5`。但是`06`其实只对应一种情况，就是`af`。这样的话两种递归出来结果都是一样的，`50-6`却多计算了一次`5-0-6`的情况，所以我们得到了`num % 100 >= 10`的条件
```kotlin
class Solution {
    fun translateNum(num: Int): Int {
        if (num in 0..9) return 1
        if (num in 10..25) return 2
        return translateNum(num / 10) 
            + if (num % 100 in 10..25) translateNum(num / 100) else 0
    }
}
```
### 解法2：动规
啊，怎么大家都在疯狂动规啊，我看不懂了呢。是递归太低效？可是也打败了78%的回答啊。我不想动规，动规好难
